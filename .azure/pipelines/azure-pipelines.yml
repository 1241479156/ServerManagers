name: $(VersionMajor).$(VersionMinor).$(VersionBuild).$(VersionRevision)

trigger:
  branches:
    include:
    - source
  paths:
    include:
    - src

pool:
#  vmImage: windows-latest
  demands: InnoSetup

variables:
  - name: ApplicationName
    value: $(Build.DefinitionName)
  - name: SolutionFile
    value: 'src/Server-Managers.sln'
  - name: ProjectFile
    value: 'src/$(ApplicationName)/$(ApplicationName).csproj'
  - name: BuildPlatform
    value: AnyCPU
  - name: BuildConfiguration
    value: Release
  - name: PublishFolder
    value: publish

stages:
- stage: build
  displayName: Build and Publish  

  jobs:
  - job: build
    displayName: Build and Publish

    steps:
    - task: PowerShell@2
      displayName: Create AgentCapabilities Environment Variables
      enabled: false
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)
      inputs:
        targetType: 'inline'
        script: |
          Function Get-AzureDevopsAgent() {
              param(
                  [Parameter(Mandatory = $true)] [string]$baseUri,
                  [Parameter(Mandatory = $true)] [string]$accessToken,
                  [Parameter(Mandatory = $true)] [int]$agentId,
                  [Parameter(Mandatory = $true)] [string]$agentName
              )

              try {
                  [Net.ServicePointManager]::SecurityProtocol = "Tls12, Tls13"

                  $headers = @{
                      Authorization = "Bearer $accessToken"
                  }

                  $uri = "$($baseUri)/distributedtask/pools?api-version=6.0"
                  $responsePools = Invoke-RestMethod -Method Get -Uri $uri -Headers $headers -UseBasicParsing
                  Write-Host $responsePools

                  foreach ($pool in $responsePools.Value) {

                      $uri = "$($baseUri)/distributedtask/pools/$($pool.Id)/agents?api-version=6.0&includeCapabilities=true"
                      $responseAgents = Invoke-RestMethod -Method Get -Uri $uri -Headers $headers -UseBasicParsing
                      Write-Host $responseAgents

                      $agents = $responseAgents.Value.Where({$_.id -eq $agentId -and $_.name -eq $agentName})
                      if (!($agents) -or $agents.Count -eq 0) {
                          continue
                      }

                      if ($agents.Count -gt 1) {
                          throw "Multiple agents ($($agents.Count)) found with id: $agentId and name: $agentName"
                      }

                      return $agents.Item(0)
                  }

                  Write-Host -ForeGroundColor Yellow 'Agent NOT found'
                  return $null
              }
              catch {

                  Write-Host -ForeGroundColor Red 'Unhandled exception occurred during agent fetch!'
                  Write-Host -ForegroundColor Red $_.Exception.Message
                  throw 
              }
          }

          Function Output-AgentCapabilities() {
              param(
                  [Parameter(Mandatory = $true)] [PSCustomObject]$capabilities,
                  [Parameter(Mandatory = $true)] [string]$capabilityType
              )

              [int]$count = 0
              foreach ($capability in $capabilities.PSObject.Properties) {
                  $envName = "AgentCapabilities.$($capabilityType).$($capability.Name)".Replace('_', '.')
                  [System.Environment]::SetEnvironmentVariable($envName, $($capability.Value))

                  $count = $count + 1
              }

              Write-Host -ForeGroundColor Cyan "Created $count AgentCapabilities.$capabilityType environment variables"
          }

          $AgentData = Get-AzureDevopsAgent -baseUri "$(System.CollectionUri)_apis" -accessToken $(System.AccessToken) -agentId $(Agent.Id) -agentName $(Agent.Name)
          if ($AgentData) {
              Output-AgentCapabilities -capabilities $AgentData.systemCapabilities -capabilityType 'System'
              Output-AgentCapabilities -capabilities $AgentData.userCapabilities -capabilityType 'User'
          }
        pwsh: true

    - task: PowerShell@2
      displayName: Output Environment Variables
      condition: contains(variables['system.debug'], 'true')
      inputs:
        targetType: 'inline'
        script: '(gci env:*).GetEnumerator() | Sort-Object Name | Out-String'
        pwsh: true

    - task: NuGetToolInstaller@1
      displayName: Install NuGet 4.4.1
      inputs:
        versionSpec: '4.4.1'

    - task: NuGetCommand@2
      displayName: NuGet Restore
      inputs:
        restoreSolution: '$(SolutionFile)'

    - task: PowerShell@2
      displayName: Apply Semantic Versioning to AssemblyInfo Files
      inputs:
        targetType: filePath
        filePath: './.azure/scripts/ApplySemanticVersioningToAssemblies.ps1'
        arguments: "-applicationName $(ApplicationName) -pathToSearch '$(Build.SourcesDirectory)/src' -buildNumber $(Build.BuildNumber) -searchFilter 'AssemblyInfo.*'"
        pwsh: true

    - task: projectfileprops@1
      displayName: Modify ApplicationVersion in Project File
      inputs:
        path: '$(ProjectFile)'
        fieldOptions: ApplicationVersion
        value: '$(VersionMajor).$(VersionMinor).$(VersionBuild).%2a'

    - task: projectfileprops@1
      displayName: Modify ApplicationRevision in Project File
      inputs:
        path: '$(ProjectFile)'
        fieldOptions: ApplicationRevision
        value: '$(VersionRevision)'

    - task: VSBuild@1
      displayName: Build $(ApplicationName) Project
      inputs:
        solution: '$(ProjectFile)'
        msbuildArgs: '/t:publish /p:PublishDir="$(Build.ArtifactStagingDirectory)"'
        platform: '$(BuildPlatform)'
        configuration: '$(BuildConfiguration)'
        clean: true

    - task: PowerShell@2
      displayName: Cleanup Published Files
      env:
        BUILD_BUILDNUMBER: $(Build.BuildNumber)
        BUILD_ARTIFACTSTAGINGDIRECTORY: $(Build.ArtifactStagingDirectory)
      inputs:
        targetType: 'inline'
        script: |
          $appVersion = $env:BUILD_BUILDNUMBER
          $appVersionWithUnderscores = $appVersion.Replace('.', '_')

          # Remove unwanted files
          Remove-Item -Path "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/*.application" -Force -ErrorAction Ignore
          Remove-Item -Path "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/*.exe" -Force -ErrorAction Ignore

          # Rename application files Folder
          $applicationFolders = Get-ChildItem -Path "$env:BUILD_ARTIFACTSTAGINGDIRECTORY\Application Files" -Filter "*_$appVersionWithUnderscores" -Directory -Name
          $applicationFolder = $applicationFolders.Where({$_.Replace(' ', '') -eq "$(ApplicationName)_$appVersionWithUnderscores"})
          if ($applicationFolder.Count -ne 1) {
              throw "Could not find the application folder ($(ApplicationName)_$appVersionWithUnderscores)"
          }
          $applicationFolderName = $applicationFolder[0]

          Rename-Item -Path "$env:BUILD_ARTIFACTSTAGINGDIRECTORY\Application Files\$applicationFolderName" -NewName "$env:BUILD_ARTIFACTSTAGINGDIRECTORY\Application Files\$(ApplicationName)_$appVersionWithUnderscores" -Force
        pwsh: true

    - task: CopyFiles@2
      displayName: Copy Artifact Files
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)'
        Contents: |
          src/$(ApplicationName)/VersionFeed.xml
          src/$(ApplicationName)/VersionFeedBeta.xml
          src/$(ApplicationName)/Art/favicon.ico
          src/$(ApplicationName)/Globalization/en-US/en-US.xaml
        TargetFolder: '$(Build.ArtifactStagingDirectory)'
        OverWrite: true
        flattenFolders: true
        preserveTimestamp: true

    - task: PowerShell@2
      displayName: Create Latest Version Files
      env:
        BUILD_BUILDNUMBER: $(Build.BuildNumber)
        BUILD_ARTIFACTSTAGINGDIRECTORY: $(Build.ArtifactStagingDirectory)
      inputs:
        targetType: 'inline'
        script: |
          $appVersion = $env:BUILD_BUILDNUMBER
          $appVersionShort = $appVersion.Substring(0, $appVersion.LastIndexOf('.'))
          $appVersionWithUnderscores = $appVersion.Replace('.', '_')

          $versionFile = "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/latest.txt"
          $AppVersionShort | Set-Content "$versionFile"

          $versionFile = "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/latestBeta.txt"
          $AppVersion | Set-Content "$versionFile"
        pwsh: true

    - task: PowerShell@2
      displayName: Create Installer File
      env:
        BUILD_BUILDNUMBER: $(Build.BuildNumber)
        BUILD_ARTIFACTSTAGINGDIRECTORY: $(Build.ArtifactStagingDirectory)
        AGENTCAPABILITIES_USER_INNOSETUP: 'C:\Program Files (x86)\Inno Setup 6\ISCC.exe'
      inputs:
        targetType: 'inline'
        script: |
          $appVersion = $env:BUILD_BUILDNUMBER
          $appVersionShort = $appVersion.Substring(0, $appVersion.LastIndexOf('.'))
          $appVersionWithUnderscores = $appVersion.Replace('.', '_')

          $installScriptFile = ".azure/scripts/$(ApplicationName).iss"
          $installTextFile = '.azure/scripts/Installer.txt'

          $installTextFileContent = @"
          #define AppVer "$appVersionShort"
          #define AppVerFull "$appVersion"
          #define AppVerPath "$appVersionWithUnderscores"
          #define RootPath "$env:BUILD_ARTIFACTSTAGINGDIRECTORY"
          "@
          #$installTextFileContent | Out-File -LiteralPath:$installTextFile -Force -Encoding ascii
          $installTextFileContent | Set-Content "$installTextFile" -Encoding Ascii -Force

          & "$env:AGENTCAPABILITIES_USER_INNOSETUP" "$installScriptFile"
        pwsh: true

    - task: PowerShell@2
      displayName: Create Duplicate ServerManager Updater File
      env:
        BUILD_BUILDNUMBER: $(Build.BuildNumber)
        BUILD_ARTIFACTSTAGINGDIRECTORY: $(Build.ArtifactStagingDirectory)
      inputs:
        targetType: 'inline'
        script: |
          $appVersion = $env:BUILD_BUILDNUMBER
          $appVersionShort = $appVersion.Substring(0, $appVersion.LastIndexOf('.'))
          $appVersionWithUnderscores = $appVersion.Replace('.', '_')

          #$fileExtension = '.application'
          #$applicationFiles = Get-ChildItem -Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY -Filter "*$fileExtension" -File -Name
          #$applicationFile = $applicationFiles.Where({$_.Replace(' ', '') -eq "$(ApplicationName)$fileExtension"})
          #if ($applicationFile.Count -ne 1) {
          #    throw "Could not find the application file ($(ApplicationName)$fileExtension)"
          #}
          #$applicationFileName = [System.IO.Path]::GetFileNameWithoutExtension($applicationFile[0])
          $applicationFolderName = "$(ApplicationName)_$($appVersionWithUnderscores)"

          $sourcePath = "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/Application Files/$applicationFolderName"
          Copy-Item -Path "$sourcePath\ServerManagerUpdater.exe" -Destination "$sourcePath\NewServerManagerUpdater.exe" -Force
        pwsh: true

    - task: PowerShell@2
      displayName: Archive Binary Files
      env:
        BUILD_BUILDNUMBER: $(Build.BuildNumber)
        BUILD_ARTIFACTSTAGINGDIRECTORY: $(Build.ArtifactStagingDirectory)
      inputs:
        targetType: 'inline'
        script: |
          $appVersion = $env:BUILD_BUILDNUMBER
          $appVersionShort = $appVersion.Substring(0, $appVersion.LastIndexOf('.'))
          $appVersionWithUnderscores = $appVersion.Replace('.', '_')

          #$fileExtension = '.application'
          #$applicationFiles = Get-ChildItem -Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY -Filter "*$fileExtension" -File -Name
          #$applicationFile = $applicationFiles.Where({$_.Replace(' ', '') -eq "$(ApplicationName)$fileExtension"})
          #if ($applicationFile.Count -ne 1) {
          #    throw "Could not find the application file ($(ApplicationName)$fileExtension)"
          #}
          #$applicationFileName = [System.IO.Path]::GetFileNameWithoutExtension($applicationFile[0])
          $applicationFolderName = "$(ApplicationName)_$($appVersionWithUnderscores)"

          $sourcePath = "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/Application Files/$applicationFolderName"
          $zipFile1 = "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/latest.zip"
          $zipFile2 = "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/$(ApplicationName)_$($appVersionShort).zip"

          Add-Type -Assembly System.IO.Compression.FileSystem
          $compressionLevel = [System.IO.Compression.CompressionLevel]::Optimal
          [System.IO.Compression.ZipFile]::CreateFromDirectory($sourcePath, $zipFile1, $compressionLevel, $false)

          Copy-Item -Path "$zipFile1" -Destination "$zipFile2" -Force
        pwsh: true

    - task: PublishBuildArtifacts@1
      displayName: Publish Artifacts
      enabled: false
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: '$(PublishFolder)'

- stage: deployBeta
  displayName: Beta
  lockBehavior: runLatest
  condition: and(succeeded(), eq(variables['build.sourceBranch'], 'refs/heads/source'))
  dependsOn: 
  - build

  jobs:
  - deployment: deployBeta
    displayName: Deploy Beta
    environment: github-servermanager-beta

- stage: deployRelease
  displayName: Production
  lockBehavior: runLatest
  condition: and(succeeded(), eq(variables['build.sourceBranch'], 'refs/heads/source'))
  dependsOn: 
  - deployBeta

  jobs:
  - deployment: deployRelease
    displayName: Deploy Production
    environment: github-servermanager-release